https://en.wikipedia.org/wiki/Structural_pattern

In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships among entities.
(or)
Structural design patterns are concerned with how classes and objects can be composed, to form larger structures.
The structural design patterns simplifies the structure by identifying the relationships.
These patterns focus on, how the classes inherit from each other and how they are composed from other classes.

Structural design pattern is about Object structure meaning whether we can
use Inheritance or Composition(Which compose of other objects) to create Objects.

Examples of Structural Patterns include:

**Required**
Adapter pattern: 'adapts' one interface for a class into one that a client expects
        Adapter pipeline: Use multiple adapters for debugging purposes.[1]
        Retrofit Interface Pattern:[2][3] An adapter used as a new interface for multiple classes at the same time.

**Required**
Aggregate pattern: a version of the Composite pattern with methods for aggregation of children


**Required**
Bridge pattern: decouple an abstraction from its implementation so that the two can vary independently
        Tombstone: An intermediate "lookup" object contains the real location of an object.[4]


**Required**
Composite pattern:
 a tree structure of objects where every object has the same interface


**Required**
Decorator pattern:
 add additional functionality to an object at runtime where subclassing would result in an exponential rise of new classes


**Not Required**
Extensibility pattern:
 a.k.a. Framework - hide complex code behind a simple interface


**Required**
Facade pattern:
 create a simplified interface of an existing interface to ease usage for common tasks


**Required**
Flyweight pattern:
 a large quantity of objects share a common properties object to save space


**Required**
Marker pattern:
 an empty interface to associate metadata with a class.


**Not Required**
Pipes and filters:
 a chain of processes where the output of each process is the input of the next


**Not Required**
Opaque pointer:
 a pointer to an undeclared or private type, to hide implementation details


**Required**
Proxy pattern:
 a class functioning as an interface to another thing